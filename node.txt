##--PRIMEIRO PROJETO

CRIANDO UM PROJETO NODE = npm init

CRIANDO UM PROJETO NODE RAPIDO = npm init -y

EXECUTANDO UM ARQUIVO = node nomeArquivo.js




#--INSTALANDO TYPESCRIPT

INSTALANDO TYPESCRIPT GLOBALMENTE = npm install -g typescript

CRIANDO ARQUIVO DE CONFIGURAÇÃO TS tsconfig.json = tsc --init





#--CONFIGURAÇÃO TYPESCRIPT

INSTALAR TYPES DO TYESPESCRIPT =  npm install --save -dev @types/node

EM TSCONFIG.JSON 

"moduleResulotion":"node" = comando que mostra que typescript vai trabalhar com o node

"outDir": "./dist" = comando que mostra onde sera a saida do javascript

"rootDir": "./src" = comando que mostra onde o ts sera trabalhado

"target": "ES6" = comando que mostra qual ecmascript vou usar

 tsc - w = roda o watchmode, monitora toda as alterações no codigo e transforme em js.




#--SCRIPTS PACKAGE.JSON

NO OBJETO SCRIPTS PORSSO CRIAR ATALHOS

"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start":"node dist/index.js", --> npm run start vai rodar o node em um diretorio especificado
    "wts":"tsc -w" --> npm run wts vai rodar o watchmode do ts
  }





#--COMMON JS

module.exports.Nomefunção = Nomefunção  -> exportando uma função em common js

const variavel = require('./Matematica') -> importando um arquivo common js




#--IMPORT EXPORT ECMASCRIPT6

export function () {} = exportando uma função no ecmascript6
import {somar} from './Matematica'
console.log(somar(2,3))  = usando função


export defaut {somar,subtrair} = exportando varias funções de maneira defaut
import Matematica from './Matematica'
Matematica.somar(2,3) = usando função


import * as Matematica from './Matematica' = importando todas as funções e chamando de Matematica do arquivo Matematica
Matematica.somar(2,3) = usando função





#--NODEMON

npm install -g nodemon = comando para instalar monitorador e executor js
nodemon ./dist index.js = executando um arquivo com o nodemon

#--TS-NODE
npm install -g ts-node = comando para instalar executor de typescript globalmente
ts-node ./src index.ts = executando ts-node

nodemon ./src index.ts = ele vai monitorar e  executar apenas o codigo typescript



#--EXPRESS

npm install express = instalando express (maneria facilitada de criar servidores,rotas)
npm install --save @types/express = instalando o auto complete do express


import express, {Request,Response} from 'express' ----> chamando o express é tambem dois tipos de requisição
const server = express()  ----> armazenando a função express em uma variavel
				
       //pagina inicial	 //types req res
server.get('/',(req:Request,res:Response)=>{
       res.send('<h1>Olá</h1>')    -----> na pagina inicial '/' quero que seja enviado uma requisição do tipo response com um titulo do site "Olá"
})


server.listen(80) --> cria o servidor na porta 80





#--ROTAS --> O QUE VEM DEPOIS DO DOMINIO

ROTAS = um caminho que pode levar a paginas,arquivos,midias,videos etc.

ROTAS ESTATICAS = rotas sem alteração, em que sua pagina e conteudo são o mesmo

ROTAS DINAMICAS = rotas com alteração, o template pode ser até o mesmo, mas o conteudo do corpo sera difirente.





#--TRABALHANDO COM ROTAS --> 
 
server.get('rota',(pedido servidor,resposta servidor)=>{
     resposta.send('mensagem que sera enviada para o usuario')
 }) 

GET = requisição para acessar algo acessar algo ao servidor
POST = requsição para mandar algo ao servidor
GET , POST , PUT , DELETE

:nome = sintaxe para rota dinamica

:nome = o usuario digitara algo, o server vai procurar algo relacionado

EXEMPLO: 
           : -> campos que serão digitados pelo usuario

  server.get('/voo/:origem-:destino',(req:Request,res:Response)=>{

    let {origem,destino} = req.params  -> como pegar o que foi digitado pelo usuario 

    res.send(`Procurando voos  de ${origem.toUpperCase()} até ${destino.toUpperCase()}`) -> enviando para o usuario o que foi digitado
})








#---CRIANDO ROTAS COM ROUTER


OBSERVAÇÃO = criar uma pasta "routers" e um arquivo index.ts nela, para guardar nossas rotas principais
OBSERVAÇÃO = dentro da pasta "routers" podemos criar outros arquivos contendo rotas de cada parte especifica do nosso sistema
EXEMPLO = painel --> rotas que são partes do painel





TODO O CODIGO ABAIXO ESTA GUARDADO EM UMA PASTA  ./routers/index

import {Router,Request,Response) from 'express' --> importando o router

const router = Router() --> guardarndo a função router em uma variavel

router.get('/',(req:Request,res:Response)=>{ 
   res.send('Olá')
  })


router.get('/contato',(req:Request,res:Response)=>{
    res.send('Formulário de Contato')
})


router.get('/sobre',(req:Request,res:Response)=>{
     res.send('Página institucional sobre a empresa')
})

export default router






TODO O CODIGO ABAIXO ESTA GUARDADO EM UMA PASTA  ./routers/painel


import {Router,Request,Response} from 'express'

const router = Router()

router.get('/',(req:Request,res:Response)=>{
     res.send('Home Painel')
})

router.get('/formulario',(req:Request,res:Response)=>{
    res.send('Formulário de Cadastro painel')
})


export default router






#--USANDO AS ROTAS CRIADAS NA PASTA routers


import mainRouters from './routers/index'
import painelRouters from './routers/painel'
import express from "express";

const server = express()

server.use(mainRouters) --> não precisa de prefixo porque a rota raiz do site e '/'
server.use('/painel',painelRouters) --> para rotas diferentes crie um prefixo indicando qual é a rota raiz das rotas diferentes, nesse caso é '/painel'


server.listen(80)







#--PÁGINA NÃO ENCONTRADA

caso ele tenha passado pelas rotas principais e não achou o espeficicado, preciso criar uma rota para ultimo recurso, caso na linha de execução o servidor não encontre nada.

server.use(mainRoutes)
server.use('/painel',routerPainel)

não achou nada
res.status(404) = quando a pagina não for encontrada
server.use((req:Request,res:Response)=>{
   res.status(404).send('Página não encontrada!')  -->caso o erro seja 404, envia para o usuario o status que a pagina não foi encontrada 
})





#--PÁGINA PUBLICA E ARQUIVOS ESTATICOS

Criar uma pasta publica e colocar arquivos e pastas para serem acessados pelo o publico externo

---public
--imgs
-google.jpg
--css
-style.css

server.use(express.static('public')) --> vai criar uma rota para a pasta public, podendo ser acessado, com conteudo estatico
posso acessar imgs,estilos,codigos e etc

exemplo : localhost/css/style.css

server.use('/static',express.static('public')) --> (opcional), colocando um prefixo para acessar as pastas

exemplo : localhost/static/css/style.css


--- OBSERVAÇÃO : caso o codigo seja executado na raiz do hd,tratamentos devem ser feitos

import path from 'path' -> import a biblioteca path do node

__dirname = especifica em qual diretorio estou

path.join(__dirname,'../public') -->caso o server esteja dentro da pasta src, comando que mostra o caminho completo para a pasta public
path.join(__dirname,'./public') -->caso o server esteja fora da pasta src, comando que mostra o caminho completo para a pasta public

server.use(express.static(path.join(__dirname,'../public'))) ---> comando que cria uma rota para a pasta publica, mas agora com o camino completo da pasta public, prevensão de erros.


server.use(express.static(path.join(__dirname,'../public'))) ---> todas as patas imgs e css são reconhecidos pelo mustache quando estão na pasta public, porque são arquivos estaticos











#--MUSTACHE



npm i mustache-express = instalar mustache express
npm i --save-dev @types/mustache-express = instalar os types do mustache



"start-dev":"nodemon -e ts,json,mustache src/server.ts" = preciso fazer com que o nodemon reconheça o mustache a cada ctrl + s, --> ts,json,mustache


import mustache from 'mustache-express' = importando a biblioteca

server.set('view engine','mustache') --> colocando no server qual sera a ferramente de visualização
server.set('views',path.join(__dirname,'./views')) --> colocando no server o nome da pasta que tera as visualizaçoes e seu caminho
server.engine('mustache',mustache())  --> chamando o mustache para a engenharia de visualização do server

res.render() = mandar um arquivo para o servidor rederizar

router.get('/',(req:Request,res:Response)=>{
     res.render('home') --> renderizando a home dentro da pasta view
})

todo arquivo de visualização precisa ter a extensão : arquivo.mustache










#--EXIBINDO INFORMAÇÕES NO MUSTACHE

router.get('/',(req:Request,res:Response)=>{
  let user = { 
    name:'Álife', ---> precisamos sempre criar nossas informações dentro da rota onde estamos
    age:49

 }
 res.render('home',{
         user,    --> as informações precisa sempre estar dentro do render para serem recebidas pelo mustache
	   test:'testando' --> posso colocar tanto um objeto como uma variavel tambem
})
})

home.mustache


 <p> Olá tudo bem {{user.name}} </>
 <p> usando apenas variavel {{test}} </p>

 











##-- EXIBIÇÃO CONDICIONAL


OBSERVAÇÃO = o arquivo mustache não consegue criar uma logica de programação, toda a logica precisa estar em um arquivo javascript, o mustache vai apenas exibir


  {{}} --> abrindo  SINTAXE PARA UMA CONDICIONAL

  {{/}} -- fechando

  
router.get('/',(req:Request,res:Response)=>{

  let age : number = 21

  let show : boolean = false

 if(age > 18){
  show = true     --->criando logica para exibição de nome
}
 else{
  show = false
}
 let user = {
  name:'Álife'
}
 
 res.render('home',{
     user,
     show 
 })
 })


home.mustache

{{#show}}
  <p>Olá {{user.name}} você é maior de idade</p>     --> caso o álife seja maior de idade ela mostra uma tag com informações, caso ela não seja, nada é mostrado.
{{/show}}














#--LOOPS



res.render('home',{
         user,
         products:[
            {title:'Produto X',price:10},
            {title:'Produto Y',price:15},       ---> array com objetos
            {title:'Produto W',price:20} 
        ],
        list:[
            'Alguma coisa legal',            -----> array simples
            'outra frase' 
        ]
        
     })



<ul>
	{{#products}} --> por si só ele faz a iteração pelos objetos
   		<li>{{title}} - R$ {{price}}</li> ---> propriedades dos objetos,maneira de exibir um array com objetos
	{{/products}}
</ul>
 

    <hr>
      {{#list}}  --> por si só ele faz a iteração pelo elementos do array
         <li>{{.}}</li> ---> quero mostrar os proprios elementos do array, maneria de exibir dados de um array simples
      {{/list}}    



      {{^list}} ----> maneira de fazer um else, caso o array esteja vazio
        Não há frases motivacionais hoje
      {{/list}}














#--CONTEUDO PARCIAL

conteudo parcial = uma forma de eu reutilizar html para outras paginas

OBSERVAÇÃO = criar uma pasta chamada "partials" dentro do "views", e colocar os arquivos mustache de view dentro de outra pasta chamada "pages" ---> separar responsibiliades


EXEMPLO : 

------ > partials/header.mustache

 <!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">            ---> como passar esse header para as outras paginas ? 
    <title>Test Mustache</title>
</head>
<body>
    <h1> Título da página </h1>
    <hr>



------> pages/home

{{>partials/header}} ---> chamando o header criando na pasta partials ------------> sintaxe : {{>pasta/arquivo.mustache}}

    {{#user.showWelcome}}
    <p>Olá Tudo Bem {{user.name}}</p>
    {{/user.showWelcome}}


    {{#user.showOld}}
      <p>{{user.name}} você  é maior que 18 anos</p>
    {{/user.showOld}}

    {{^user.showOld}}
        <p>{{user.name}} você não é maior que 18 anos</p>
    {{/user.showOld}}
  

    <hr/>
    
    <h2>Produtos</h2>
    <ul> 
    {{#products}}
      {{>partials/productItem}}
    {{/products}}
    </ul>
 
    <hr>
      {{#list}} <!--Maneira de exibir um array normal-->
         <li>{{.}}</li>
      {{/list}}    

      {{^list}}  <!--maneira de fazer um else-->
        Não há frases motivacionais hoje
      {{/list}}


{{>partials/footer}} ------> chamando o footer criando na pasta parials
 





 partials/footer  :
	
	<hr/>
	Todos os direitos reservados
	</body>
	</html>


















#--PEGANDO DADOS PELA URL




req.query ---> retorna um objeto com as propriedades fornecidades da url



as string ---> precisa ser declarada pq o req.query tem varios tipos, e especificamos com qual vamos trabalhar



req.query.nome = acessando a propriedade nome do objeto query



router.get('/nome',(req:Request,res:Response)=>{

    let nome : string = req.query.nome as string  ---> pegando dados da url
    let sobrenome : string = req.query.sobrenome as string  ---> pegando dados da url

    res.render('pages/nome',{
         nome,             ----> passando os dados para o mustache  
         sobrenome
    })

})


GET  = requisição para pegar algo no servidor
GET = quando uso o metodo GET, os dados do form aparacem na barra de pesquisa



nome.mustache


{{>partials/header}}
      <h2>Qual seu nome?</h2>
      <form method="GET"> 
            <input type='text' name='nome' placeholder="Digite seu nome" /> <br/>
            <br/>
            <input type='text' name='sobrenome' placeholder="Digite seu sobrenome" /> <br/>
             <br/>
            <input type = 'submit' value = 'ENVIAR'/>
      </form>


      {{#nome}}
            <hr/>
            Olá {{nome}} de {{sobrenome}}, tudo bem ?        ----------> exibindo informações
      {{/nome}}


{{>partials/footer}}
















#--PEGANDOS OS DADOS PELA URL 2





// Erro: Variable 'x' is used before being assigned. usando o compilador está alertando que você está tentando acessar o valor de uma variável que ainda não foi inicializada com um valor.


router.get('/idade',(req:Request,res:Response)=>{


    let idade : number = 0  ---> Retirando ERROR
    let showAge : boolean = false ---> CRIANDO UM CONDICIONAL DE EXIBIÇÃO


    if(req.query.ano){  ----->  verificando se houver uma query na requisição chamada "ano"
        let anoNascimento : number = parseInt(req.query.ano as string)   ---> transformando em inteiro
        let anoAtual : number = new Date().getFullYear() ----> pegando o ano atual
        idade = anoAtual - anoNascimento -----> calculando a idade
        showAge = true ------------> usando a condicional de exibição
    }
    
     res.render('pages/idade',{
         idade,      ----> mandando a variavel idade  para o mustache
         showAge	 -----> mandando o condicional de exibiçao para o mustache
     })
})













#--ENVIANDO DADOS VIA POST


POST = enviar os dados internamente, sem apareçar na url

server.use(express.urlencoded({extended:true}))  ------> precisa configurar o servidor para  pegar os dados do corpo da requisição dentro da rota

extend:true --> mostra os dados detalhadamente


router.get('/idade',(req:Request,res:Response)=>{        ---> mudo a minha rota para apenas renderizar a pagina
        res.render('pages/idade')
})


router.post = preciso usar porque estou utilizando a requisição post 

'/idade-resultado'  ---> meu action, para poder criar outra rota com resultado e reutilizar layout

req.body = utilizo o req.body porque estou mandando os dados agora internamento pelo corpo da requisição

router.post('/idade-resultado',(req:Request,res:Response)=>{
    let idade : number = 0
    let showAge : boolean = false
    if(req.body.ano){
        let anoNascimento : number = parseInt(req.body.ano as string)         ---> agora as manipulaçoes de idade são feitas dentro do post
        let anoAtual : number = new Date().getFullYear()
        idade = anoAtual - anoNascimento
        showAge = true
    }
    
     res.render('pages/idade',{
         idade,     ---> mandando a idade para o mustache
         showAge     ---> mandando a condicional de exibição para o mustache
     })
})




{{>partials/header}}
   <form method = 'POST' action = '/idade-resultado'>  --->o formulario vai mandar suas informações internamente pelo corpo da requisição
     ---> e o será criada outra rota para exibir o resultado 


    <input type='number' name='ano' placeholder='digite seu ano de nascimento'/> 
    <br/><br/> <input type = 'submit' value = 'ENVIAR'/>
   </form>
      {{#showAge}}
            <hr/>
            Olá sua idade é {{idade}}
      {{/showAge}}
{{>partials/footer}}
















#----MVC 



M = Model      ----> pasta que faz as manipulaçoes,processamento
V = View       ----> pasta com as visualizações , html,css
C = controller ----> pasta que direcionam os resultados do processamento para o view,intermediador







#----VARIAVEIS DE AMBIENTE    





variaveis de ambiente ---> são utilizados quando tenho padrões no meu ambiente de desenvolvimento que podem diferir quando outras pessoas usarem


instalação ---> npm install dotenv



no server.ts

import dotenv from 'dotenv' ---> importando o dotenv

dotenv.config() ---> chamando suas configurações

crio um arquivo chamado .env




EX:

quero parametrizar a porta do servidor, caso esse arquivo for para outro ambiente , a pessoa possa alterar apenas o arquivo .env, e não ficar procurando  o "server.listen" no serve.ts

no .env

PORT=4000  ---> meu padrão de desenvolvimento



Chamando no server.ts

server.listen(process.env.PORT)    ---> ele vai entrar no arquivo .env e colocar no serve.listen a variavel do .env chamado "PORT"








#---COLOCANDO O PROJETO NO AR



1- CRIAR UM ARQUIVO CHAMADO "Procfile",na raiz do projeto,  o servidor vai ler esse arquivo e executar os comandos dentro dele

NO ARQUIVO : 

COLOCAR COMANDO --> web:npm start  ---> o servidor vai executar esse comando para compilar o projeto




2 - CRIAR O COMANDO "START" NO Package.json


colocar no objeto "scripts" ---> "start": "node dist/server.js" ---> o servidor vai saber a localização do arquivo para executar


o dist ainda não foi criado. ele vai ser rodado com o tsc, porem precisamos instalar uma blibioteca para copiar os arquivos mustache para o dist


se eu rodar apenas o tsc, o dist será criado , porem apenas os arquivos mvc,server,helpers vão para ele, menos os arquivos mustache.


3 - INSTALAR O COPIADOR DE ARQUIVOS

comando ---->  npm install --save-dev copyfiles

colocoar a execução dele no "scripts" do package.json

"postinstall": "tsc && copyfiles -u 1 src/**/*.mustache dist/" ---> esse comando transformar os arquivos ts em js e coloca no dist, e copia todos os arquivos mustache para o dist tambem. o '-u 1' garante a copia dos arquivos mustache modificados.


4- RODAR OS COMANDOS

npm run postinstall 

npm run start








#-- CRIAÇÃO DE API

--  API 

-- Application Programming Interface


API --> INTERMEDIARIO  BUSCA OS DADOS DO BANCO PARA ENTREGAR AO USUARIO

Webservices = Serviços da Web, site sem interface grafica  apenas com texto puro



- REST ---> UMA TEORIA UM PADRÃO
-- Representational State Transfer
-- Transferência de Estado Representacional


- RESTful --> SISTEMA QUE USA O PADRÃO REST

__________________________________________


REST OBJETIVO --> TRABALHAR COM URL PARA ESPICICAR A API O QUE ESTAMOS FAZENDO

ENDPOINT = URL COMPLETA

GET = REQUISIÇÃO PARA PEGAR DADOS

PUT = REQUISIÇÃO PARA MODIFICAR DADOS

POST = REQUISIÇÃO PARA ADICIONAR UMA INFORMAÇÃO 

DELETAR = REQUISIÇÃO PARA DELETAR UMA INFORMAÇÃO




npm install dotenv express pg  pg-hstore sequelize validator ---> instalar varios pacotes de uma só vez


npm install -D @types/express @types/node @types/sequelize @types/validator  --> instalar varios types de uma vez só






#--REDIRECIONAR A PAGINA

res.redirect('/') ---> voltar para a pagina inicial


# --- ENTENDENDO CORS



npm install cors ---> instalar o  cors

npm install --save @types/cor ---> instalar types do cors


no server.ts

import cors from 'cors'

origin:'*' --> permitir todas as origens

server.use(cors({    --> vou chamar o cors quando iniciar o servidor
      origin:'https://resttesttest.com', --> vou permitir que esse link acesse minha api
      methods:['GET','POST'] --> apenas o metodo get e post
}))


cors == libera o acesso entre as apis





# -- UPLOAD DE IMAGES

REGRAS:

Em postman
Geralmente enviado pelo metodo POST
Não utilizando o x-www-form-urlencoded mas sim o form-data





# -- BLIBLIOTECAS DE UPLOAD


npm install multer --> instalando multer

npm install --save @types/multer ---> instalando types do multer







# -- ENVIANDO UMA IMAGEM COM MULTER

import multer from "multer" ---> importação do multer

const upload = multer({dest:'./tmp'}) ---> configurando para onde vai o arquivo, antes de manda-lo para o public vamos fazer modificações nele , por isso enviamos para uma pasta temporaria(tmp)

router.post('/upload', upload.single('avatar'),uploadController.uploadFile) ---> pegando o campo do formulario que tera o nome de avatar, e mandando para o controllers

no controller

export const uploadFile = async (req:Request,res:Response)=>{
    console.log(req.file)  --> mostrar as informações do arquivo quando a requisição for efetuada
    res.json({}) --> responder apenas um objeto (para teste)
}


enviando 2 arquivos

router.post('/upload', upload.array('avatars',2),uploadController.uploadFile) --> mudo o nome para avatars no plural e  especifico que quero apenas 2 arquivos pode ser 1 ou 2

console.log(req.files) --> 'files' --> para mostrar mais de um arquivo


enviando mais de um arquivo

router.post('/upload', upload.fields([
     {name:'avatar',maxCount:1}, --> especificando o campo e quantidade maxima de arquivos
     {name:'gallery',maxCount:3} --> especificando o campo e quantidade maxima de arquivos
]),uploadController.uploadFile)


export const uploadFile = async (req:Request,res:Response)=>{
   
 const files  = req.files as {[fieldname:string]:Express.Multer.File[]} --> informando ao ts que vou colococar qualquer nome para propriedade do objetos files, e que essa variavel e do tipo que array que contem varios objetos do tipo multer file

    console.log('AVATAR',files.avatar) --> mostrando as informações do avatar
    console.log('GALLERY',files.gallery) --> mostrando as informações da galeria

    res.json({})
}




# -- TIPOS DE STORAGE

const storageConfig = multer.diskStorage({ // diskStorage = vou armazenar no disco de armazenamento da maquina
      destination:(req:Request,file:Express.Multer.File,cb)=>{ // responsavel para destino de armazenamento do arquivo
               cb(null,'./tmp') // --> destino para .tmp
      }, 
      filename:(req:Request,file:Express.Multer.File,cb)=>{ //--> responsavel pelo nome do arquivo
          let randomName = Math.floor(Math.random() * 99999) // --> gera um numero aleatorio
          cb(null,`${randomName + Date.now()}.jpg`) --> o nome do arquivo vai ser um numero aleatorio mais a data atual em timesstap mais uma extesnao jpg
      }
})

const upload = multer({
     storage:storageConfig --> especificando que meu multer vai receber as configurações do storageConfig
    })

router.post('/upload',upload.single('avatar'),uploadController.uploadFile) --> rota que vai utilizar as configurações






# -- VALINDANDO ARQUIVOS


const upload = multer({
     dest:'./tmp',
     fileFilter:(req,file,cb)=>{
          cb(null,false) ->  não aceita nada que for enviado
          cb(null,true)  -> aceita tudo que for enviado
         const allowed:string[] = ['image/jpg','image/jpeg','image/png']  -> especifico os tipos permitidos de imagem para validação
         cb(null,allowed.includes(file.mimetype)) -> o arquivo sera liberado caso o arquivo esteja incluso nos tipos definidos
        },
        limits:{fieldSize:20000000}  -> especificar o tamanho do aceitavel para do arquivo 20mb
        
    })





# -- Lidando com erros de upload

Em server.ts 

Importamos: import express,{Request,Response,ErrorRequestHandler, NextFunction} from 'express' --> error de requisição
	    import { MulterError } from 'multer' --> Tratativas de erro do multer
		
	
const errorHandler : ErrorRequestHandler = (err:Error,req:Request,res:Response,next:NextFunction) =>{ --> criamos uma função passando nossos parametros de error,req,res e next
    res.status(400) //Bad Request  --> responde que houve uma falha na requsição por parte do usuario
    if(err instanceof MulterError){ --> se o error for do multer
        res.json({error:err.code,errorField:err.field,errorMessage:err.message,errorName:err.name,errorStack:err.stack})
	/*
	  err.code -> mostra o codigo do error,
	  err.field -> mostra o parametro da rota que esta causando error, no caso o 'avatar'
          err.message -> mensagem de error comun especificando o error causado
	  err.name -> o error pertece a qual depedencia, no caso 'MulterError'
	  err.stack -> erro gigante que especifica as localizações da imagem no dispositivos e dependencias
	*/
    }else{ --> caso não seja 
        console.log(err)  --> mostre o erro para o cliente
        res.json({error:'Ocorreu algum erro'}) --> e mostre o error pelo json
    }

}

server.use(errorHandler) --> coloque no servidor nossa função









# -- REDIMESIONAMENTO DE IMAGES

npm install sharp --> instalação sharp

npm install -D @types/sharp --> instalção types sharp

if(req.file){
        await sharp(req.file.path).resize(300,300,{ -> pego o caminho do arquivo, redimesiono a imagem de 300 de largura e 300 de altura
             fit:sharp.fit.cover, -> quero que seja cover(cobertura) centralizado por padrão
             position:'bottom' --> quero sua posição bottom em baixo
        }).toFormat('jpeg').toFile(`./public/media/${req.file.filename}.jpg`) --> quero em formato jpeg para a localização media da pasta public, com nome do arquivo e extensão jpg
        res.json({image:`${req.file.filename}.jpg`}) --> se ocorreu tudo certo mostra o arquivo para o dev
    }else{
        res.status(400).json({error:'Arquivo inválido'})
    }


tipos de sharp fit --> fill,cover,contain,outside,inside
tipos position: 'bottom' ,'left','right','center','top' --> permite ate a combinação dessas posições






# -- DELETANDO UMA IMAGEM TEMPORARIA

import {unlink} from 'fs/promises' --> imporamos o unlink do file system promises


if(req.file){
        const filename : string = `${req.file.filename}.jpg`
        await sharp(req.file.path).resize(300,300,{
             fit:sharp.fit.cover,
             position:'center'
        }).toFormat('jpeg').toFile(`./public/media/${filename}`)   --> depois de toda manipulação da imagem e envio para pasta media
        await unlink(req.file.path) --> exclua ou não envie o arquivo para a pasta temp
        res.json({image:`${filename}`})
    }else{
        res.status(400).json({error:'Arquivo inválido'})
    }







# -- Autenticação Email

Autenticação = identeificar quem esta tentando acessar o sistema

Autorização = verificar se o OBJETO ou requisitor pode acessar aquela área do sistema


- Single-factor Authenticaion = Autenticação de 1 fator. baseado em autenticação de usuario e senha


- Two-factor Authentication(2FA) = Autenticação em 2 fatores , baseado em autenticação de usuario e senha , porem , mais algum outro fator que comprove que é você

- Multi-factor Authentication (MFA) = Autenticação em múltiplos fatores

- Single Sign-On (SSO) = Autenticação única "universal", autenticão baseada em sistemas que compartilham mesma empresa.  Ex: se eu logar no google , automaticamente ja estarei logado no youtube



# -- Tipos Auth

token = hash de codigo que identifica um usuario que quer fazer uma requisição, o token é temporario

RefreshToken = sempre me será gerado um token, quando expirar o anterior

- Basic Auth - BASE64  = A cada requisição sempre será enviado o usuario no cabeçalho da requisição e senha em base64

- OAuth (1 e 2) 
   OAuth1 = Usar um terceiro para gerar um token.  Ex: Login com Facebook
   OAuth2 = OAuth1 +  RefreshToken
   JWT(Json Web Token) = Feito pelo servidor, o server gera o token e manda para o usuario, token serve para identificar um acesso, que é lido pelo servidor, o token sempre será enviado no cabeçalho da requisição
 




# --  Introdução a Testes, TDD e Tipos

 - Testes são pedaços de código que voce cria para ter certeza que uma parte do sistema continua funcionando

 - TDD (Test-Driven Development) = Desenvolvimento orientado a testes

 - Tipos de testes:

 -- Testes unitários(unit test) --> testar uma parte isolada do codigo, apenas uma unidade de codigo  Ex: testar a um model e a conexão com banco de dados ainda é um teste unitario
pois ainda estou testando uma parte isolada(unidade de codigo)

 -- Testes de integração (integration test) --> testar se uma parte e outra parte de codigo funcionam juntas Ex: Criar um usuario e logar com usuario

 -- Testes end-to-end (e2e test) --> teste que parte da experiencia do usuario, usando telas(interfaces) geralmente focados na interface



# -- Configurando o Jest no seu projeto

npm install -D jest ts-jest @types/jest  --> Instalando Jest e types

npx ts-jest config:init --> criar jest.config.js : propriedades de configurações do jest


jest.config.js

/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  detectOpenHandles:true --> adicionar esse propriedade para detectar requisiçoes e processos assicronos
};


em scripts do package.json : 

- Observação  não precisa do 'set' no linux

 "scripts": {
    "test": "set NODE_ENV=test& jest --runInBand", --> colocar o test para rodar o jest em em sequencia 
    "start-dev": "nodemon -e ts,json src/server.ts"
  },



# -- Criando uma função apartir do teste

import {Math} from './Math'

describe('describe group test',()=>{}) --> sintaxe para criar uma grupo de testes

it('finally or objective of test',()=>{}) -> sintaxe pra criar um teste unitario/individual

expect(Math.mult(5,10)).toBe(50) -> maneira para chamar uma função e testa-la, fica dentro do it

expect = espero
toBe = que seja/resultado


describe('Test lib math',()=>{
    it('should  sum two number correctly',()=>{
        const response =   Math.sum(5,10)
        expect(response).toBe(15)
    })
    it('should  subtract two numbers correctly',()=>{
         const response = Math.sub(4,2)
         expect(response).toBe(2)
    })
    it('should  multiply two numbers correctly',()=>{
        const response = Math.mult(5,2)
        expect(response).toBe(10)
        expect(Math.mult(0,3)).toBe(0)
    })
    it('should  divisor two numbers correctly',()=>{
        const response = Math.div(8,2)
        expect(response).toBe(4)
        expect(Math.div(15,5)).toBe(3)
        expect(Math.div(3,0)).toBe(false)
	toBeFalsy() --> verificar se o valor é falso
        toBeTruthy() --> verificar se o valor é verdadeiro
    })
})



# -- Tipos de Matches

describe('types matches',()=>{
    
    it('count caracter in string',()=>{
         expect('alife').toHaveLength(5) // verifica se uma string possui o tamanho 5
    })
    it('verify property email',()=>{
         const response = {
             name:'Álife',
             email:'suporte@b7web.com'
         }
         expect(response).toHaveProperty('email') // verifica se o objeto possui a proprieadade email
         //expect(response).toBeUndefined() // verifica a variavel esta indefinida
        // expect(response).not.toBeUndefined() // verifica se a variavel não é undefined
        })
    it('verify numbers',()=>{
         const number = 20
         expect(number).toBeGreaterThan(15) // verifica se a variavel é maior que 15
         expect(number).toBeGreaterThanOrEqual(18) //verifica se o numero é maior ou igual a 18
         expect(number).toBeLessThan(50) // verifica se o valor é menor que 50
         expect(number).toBeLessThanOrEqual(50) //verifica se o valor é menor ou igual a 50
        })
    it('check if a string is an email',()=>{
        const response = 'alife.silva@unifesspa.edu.br'
        expect(response).toMatch(/^[^\s@]+@unifesspa\.edu\.br$/)
         
    })
})



# -- Lifecycle para teste 

    beforeEach(()=>{}) // -- função que executa antes de cada teste
    afterEach(()=>{}) //--> função que executa depois de cada teste
    beforeAll(()=>{}) // --> executa antes de qualquer teste
    afterAll(()=>{}) //  --> executa depois de qualquer teste


# -- INSTALAR BCRYPT

npm install bcrypt

npm install -D @types/bcrypt


# -- CRIANDO SERVICES PARA AUTH

UserService.ts:

export const createUser = async (email:string,password:string) => {
    const hasUser = await User.findOne({where:{email}})
    if(!hasUser){
        const hash = bcrypt.hashSync(password,10)
        const newUser = await User.create({
            email,
            password:hash
        })
        return newUser
    }
    else{
        return new Error ('É-mail já existe')
    }
}
export const findByEmail = async (email:string) =>{
    return await User.findOne({where:{email}})
}
export const matchPassword = (passwordText:string,encrypted:string)=>{
    return bcrypt.compareSync(passwordText,encrypted)
}
export const all = async () => {
    return await User.findAll()


apiController.ts:

export const ping = (req: Request, res: Response) => {
    res.json({pong: true});
}
//controleer apenas verifica os campos e pega os valores do campo e mandar para o service
export const register = async (req: Request, res: Response) => {
    if(req.body.email && req.body.password) {
        let { email, password } = req.body;
        const newUser = await UserService.createUser(email,password)
        if(newUser instanceof Error){
            res.status(400).json({error:newUser.message})
        }
        else {
            res.status(201).json({ id: newUser.id });
        }
    }
    else {
        res.status(400).json({ error: 'E-mail e/ou senha não enviados.' });
    }
  
}

export const login = async (req: Request, res: Response) => {
    if(req.body.email && req.body.password) {
        let email: string = req.body.email;
        let password: string = req.body.password;
        const user = await UserService.findByEmail(email)
        if(user && UserService.matchPassword(password,user.password)) {
            res.json({ status: true });
            return;
        }
    }

    res.json({ status: false });
}

export const list = async (req: Request, res: Response) => {
    let users = await UserService.all()
    let list: string[] = [];

    for(let i in users) {
        list.push( users[i].email );
    }

    res.json({ list });
}



# -- CRIANDO BANCO DE DADOS PARA TESTES

Variaveis de  ambiente para testes

MYSQL_TEST_DB=auths_test
MYSQL_TEST_USER=root
MYSQL_TEST_PASSWORD=senhapadraodoalife
MYSQL_TEST_PORT=3306

instances/mysql.ts:

import { Sequelize } from "sequelize";
import doteenv from 'dotenv'
import db from "./database";
doteenv.config()

export const sequelize = new Sequelize( ->-- torno os dados  para acessar o banco relativos, se for acesso normal, usa os dados do banco, se for para testes, usa o banco de testes
     db.db,
     db.user,
     db.password, {
         dialect:'mysql',
         port:parseInt(db.port) 
     }
)

em instances/database.ts:

import dotenv from 'dotenv'
dotenv.config()
let db = {
        db:process.env.MYSQL_DB  as string,
        user:process.env.MYSQL_USER as string,
        password:process.env.MYSQL_PASSWORD as string,
        port: process.env.MYSQL_PORT as string
}
if(process.env.NODE_ENV === 'test'){
    db={
        db:process.env.MYSQL_TEST_DB  as string,
        user:process.env.MYSQL_TEST_USER as string,
        password:process.env.MYSQL_TEST_PASSWORD as string,
        port: process.env.MYSQL_TEST_PORT as string
    }
}
export default db



# -- Teste do service:


import * as UserService from './UserService'
import {User,UserInstance} from '../models/User'
import exp from 'constants'
 describe.only('Testing user service',()=>{
    const mock = {
         email:'alifesilva90@gmail.com',       --> dados fakes para teste
         password:'1234'
    }
    beforeAll( async ()=>{
         await User.sync({force:true}) --> antes do teste iniciar crie uma tabela chamada usuario
     })
     it('should create a new user ',async ()=>{
          const newUser = await UserService.createUser(mock.email,mock.password) as UserInstance --> crie um usuario
          expect(newUser).not.toBeInstanceOf(Error) --> espere que o novo usuario não tenha error, se não tiver , o usuario foi criado com sucesso
          expect(newUser).toHaveProperty('id') --> espere que o usuario tenha a propriedade id , se o usuario for criado
          expect(newUser.email).toBe(mock.email) --> espere que o usuario criado tenha o email igual ao do mock, se o usuario for criado com sucesso
        })
     it('should not allow to create a user with existing email',async()=>{
        const newUser = await UserService.createUser(mock.email,mock.password) as UserInstance      
        expect(newUser).toBeInstanceOf(Error) ---> espera um error do usuario caso seja inserido o mesmo valo de email e senha
     })
     it('should find a user by the email',async ()=>{
         const findUser = await UserService.findByEmail(mock.email) as UserInstance
         expect(findUser.email).toBe(mock.email) espera que o email do usuario encontrado seja o mesmo do fornecido
     })
     it('Should match the password from database', async()=>{
        const findUser = await UserService.findByEmail(mock.email) as UserInstance
        const match =  UserService.matchPassword(mock.password,findUser.password)
        expect(match).toBeTruthy() --> espera que a comparação de senha seja verdadeira
     })
     it('Should not match the password from database', async()=>{
        const findUser = await UserService.findByEmail(mock.email) as UserInstance
        const match =  UserService.matchPassword('invalid',findUser.password) --> passando outro valor de senha para forçar error
        expect(match).toBeFalsy() --> espera que a comparação de senha seja falsa
     })
     it('should get a list of user',async()=>{
         const users = await UserService.all()
         expect(users.length).toBeGreaterThanOrEqual(1) --> espera que a lista possua um tamanho maior ou igual a 1
         for(let i in users){
            expect(users[i]).toBeInstanceOf(User) --> espera que cada usuario seja da instancia User ou verifica se a lista é de usuarios
         }
     })
})




# -- Testes de requisição

npm install -D supertest @types/supertest -> instalação do supertest

app.ts:

import express, { Request, Response, ErrorRequestHandler } from 'express';
import path from 'path';
import dotenv from 'dotenv';
import cors from 'cors';
import apiRoutes from './routes/api';

dotenv.config();

const server = express();

server.use(cors());

server.use(express.static(path.join(__dirname, '../public')));
server.use(express.urlencoded({ extended: true }));

server.get('/ping', (req: Request, res: Response) => res.json({ pong: true }));

server.use(apiRoutes);

server.use((req: Request, res: Response) => {
    res.status(404);
    res.json({ error: 'Endpoint não encontrado.' });
});

const errorHandler: ErrorRequestHandler = (err, req, res, next) => {
    res.status(400); // Bad Request
    console.log(err);
    res.json({ error: 'Ocorreu algum erro.' });
}
server.use(errorHandler);

export default server





server.ts:

import app from './app'
import dotenv from 'dotenv'  ---> no server.ts agora importamos as configurações de server do app para  criação de testes de requisições utilizando o supertest

dotenv.config()

app.listen(process.env.PORT)






api.test.ts:



import request from 'supertest'
import app from '../app'
import { User } from '../models/User'
describe('Testing api routers',()=>{
    const mock = {
         email:'test@jest.com',
         password:'1234'
    }
    beforeAll( async ()=>{
        await User.sync({force:true})
    })
    it('should return ping pong',(done)=>{
         request(app) --> cria outro server para testar as nossas requisições
         .get('/ping')
         .then(response => {
             expect(response.body.pong).toBeTruthy() --> espera que o conteudo do json da requisição seja true
             return done() --> indicar para o supertest que o teste em especifico ja acabou
         })
    })

    it('should register a new user',(done)=>{
        request(app)
        .post('/register')
        .send(`email=${mock.email}&password=${mock.password}`)
        .then(response => {
            expect(response.body.error).toBeUndefined() --> espera que não tenha erro
            expect(response.body).toHaveProperty('id') --> espera que o body tenha uma proprieadade id
            return done()
        })
   })
   it('should not allow to register with existing email',(done)=>{
    request(app)
    .post('/register')
    .send(`email=${mock.email}&password=${mock.password}`)
    .then(response => {
        expect(response.body.error).not.toBeUndefined() --> espera que tenha erro por causa do reenvio de dados
        return done()
    })
})
it('should not allow to register without password',(done)=>{
    request(app)
    .post('/register')
    .send(`email=${mock.email}`)
    .then(response => {
        expect(response.body.error).not.toBeUndefined()
        return done()
    })
})
it('should not allow to register without email',(done)=>{
    request(app)
    .post('/register')
    .send(`password=${mock.password}`)
    .then(response => {
        expect(response.body.error).not.toBeUndefined()
        return done()
    })
})
it('should not allow to register without any data',(done)=>{
    request(app)
    .post('/register')
    .send(``)
    .then(response => {
        expect(response.body.error).not.toBeUndefined()
        return done()
    })
})
it('should login correctly',(done)=>{
    request(app)
    .post('/login')
    .send(`email=${mock.email}&password=${mock.password}`)
    .then(response => {
        expect(response.body.error).toBeUndefined()
        expect(response.body.status).toBeTruthy()
        return done()
    })
})
it('should not login with incorrect data',(done)=>{
    request(app)
    .post('/login')
    .send(`email=${mock.email}&password=invalid`)
    .then(response => {
        expect(response.body.error).toBeUndefined()
        expect(response.body.status).toBeFalsy()
        return done()
    })
})
it('should list users',(done)=>{
    request(app)
    .get('/list')
    .then(response => {
        expect(response.body.error).toBeUndefined()
        expect(response.body.list.length).toBeGreaterThanOrEqual(1)
        expect(response.body.list).toContain(mock.email)
        return done()
    })
})
})




